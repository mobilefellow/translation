---
title: Xcode Build Configuration Files
author: Mattt
category: Xcode
excerpt: >-
  Software development best practices prescribe 
  strict separation of configuration from code.
  Learn how you can use `xcconfig` files 
  to make your Xcode projects more compact, comprehensible, and powerful.
status:
  swift: 5.0
---

---
title: Xcode Build é…ç½®æ–‡ä»¶
author: Mattt
category: Xcode
excerpt: >-
  è½¯ä»¶å¼€å‘æœ€ä½³å®è·µè§„å®šäº†é…ç½®ä¸ä»£ç çš„ä¸¥æ ¼åˆ†ç¦»ã€‚å­¦ä¹ å¦‚ä½•ä½¿ç”¨ `xcconfig` æ–‡ä»¶è®©ä½ çš„ Xcode é¡¹ç›®æ›´åŠ ç´§å‡‘ã€æ˜“æ‡‚ã€å¼ºå¤§ã€‚
status:
  swift: 5.0
---

Software development best practices
[prescribe](https://12factor.net/config)
strict separation of configuration from code.
Yet developers on Apple platforms
often struggle to square these guidelines with Xcode's project-heavy workflow.

è½¯ä»¶å¼€å‘æœ€ä½³å®è·µ [è§„å®šäº†](https://12factor.net/config) é…ç½®ä¸ä»£ç çš„ä¸¥æ ¼åˆ†ç¦»ã€‚ç„¶è€Œï¼Œè‹¹æœå¹³å°ä¸Šçš„å¼€å‘äººå‘˜å¸¸å¸¸éš¾ä»¥å°†è¿™äº›æŒ‡å¯¼åŸåˆ™ä¸ Xcode ç¹é‡çš„é¡¹ç›®å·¥ä½œæµç¨‹ç»“åˆèµ·æ¥ã€‚

Understanding what each project setting does
and how they all interact with one another
is a skill that can take years to hone.
And the fact that much of this information
is buried deep within the GUIs of Xcode does us no favors.

äº†è§£æ¯ä¸ªé¡¹ç›®è®¾ç½®çš„åŠŸèƒ½ä»¥åŠå®ƒä»¬ä¹‹é—´å¦‚ä½•äº¤äº’ï¼Œæ˜¯ä¸€é¡¹éœ€è¦å¤šå¹´ç£¨ç»ƒçš„æŠ€èƒ½ã€‚ä½† Xcode å°†å¤§éƒ¨åˆ†çš„è¿™ç±»ä¿¡æ¯éƒ½éƒ½æ·±åŸ‹åœ¨å…¶å›¾å½¢åŒ–ç•Œé¢ä¸­ï¼Œè¿™å¯¹æˆ‘ä»¬æ²¡æœ‰ä»»ä½•å¥½å¤„ã€‚

Navigate to the "Build Settings" tab of the project editor,
and you'll be greeted by _hundreds_ of build settings
spread across layers of projects, targets, and configurations ---
_and that's to say nothing of the other six tabs!_

å¯¼èˆªåˆ°é¡¹ç›®ç¼–è¾‘å™¨çš„ "Build Settings" tabï¼Œä½ ä¼šçœ‹åˆ°åˆ†å¸ƒåœ¨ projectã€target å’Œ configuration ä¸Šçš„ _æ•°ç™¾æ¡_ Build Settingï¼ˆæ„å»ºé…ç½®ï¼‰ â€”â€” _æ›´åˆ«è¯´å…¶ä»–å…­ä¸ª tab äº†!_

<picture>
    <source srcset="{% asset xcconfig-project-build-settings--dark.png @path %}" media="(prefers-color-scheme: dark)">
    <img src="{% asset xcconfig-project-build-settings--light.png @path %}" alt="Xcode build settings">
</picture>

![](https://nshipster.com/assets/xcconfig-project-build-settings--light-f7043782f0b56d637bec89eefa0d37939b38ef33f55c293e326d3fecbc06df49.png)

Fortunately,
there's a better way to manage all of this configuration
that doesn't involve clicking through a maze of tabs and disclosure arrows.

å¹¸è¿çš„æ˜¯ï¼Œæœ‰ä¸€ä¸ªæ›´å¥½çš„åŠæ³•ï¼Œä¸å¿…ç‚¹å‡»è¿·å®«èˆ¬çš„ tab å’Œç®­å¤´ï¼Œå°±å¯ä»¥ç®¡ç†æ‰€æœ‰çš„é…ç½®ã€‚

This week,
we'll show you how you can use text-based `xcconfig` files
to externalize build settings from Xcode
to make your projects more compact, comprehensible, and powerful.

è¿™ä¸€å‘¨ï¼Œæˆ‘ä»¬å°†å‘ä½ å±•ç¤ºå¦‚ä½•åœ¨ Xcode ä¹‹å¤–ï¼Œé€šè¿‡ä¿®æ”¹åŸºäºæ–‡æœ¬çš„ `xcconfig` æ–‡ä»¶ï¼Œè®©ä½ çš„é¡¹ç›®æ›´åŠ ç´§å‡‘ã€æ˜“æ‡‚ã€å¼ºå¤§ã€‚

---

[Xcode build configuration files](https://help.apple.com/xcode/mac/8.3/#/dev745c5c974),
more commonly known by their `xcconfig` file extension,
allow build settings for your app to be declared and managed without Xcode.
They're plain text,
which means they're much friendlier to source control systems
and can be modified with any editor.

[Xcode Build é…ç½®æ–‡ä»¶](https://help.apple.com/xcode/mac/8.3/#/dev745c5c974)ï¼Œå³å¤§å®¶æ‰€çŸ¥çš„ `xcconfig` æ–‡ä»¶ï¼Œå…è®¸æˆ‘ä»¬åœ¨ä¸ä½¿ç”¨ Xcode çš„æƒ…å†µä¸‹å£°æ˜å’Œç®¡ç† APP çš„ Build Settingã€‚å®ƒä»¬æ˜¯çº¯æ–‡æœ¬çš„ï¼Œè¿™æ„å‘³ç€å®ƒä»¬å¯¹ä»£ç ç®¡ç†ç³»ç»Ÿæ›´åŠ å‹å¥½ï¼Œè€Œä¸”å¯ä»¥è¢«ä»»æ„ç¼–è¾‘å™¨ä¿®æ”¹ã€‚

Fundamentally,
each configuration file consists of a sequence of key-value assignments
with the following syntax:

ä»æ ¹æœ¬ä¸Šè¯´ï¼Œæ¯ä¸ªé…ç½®æ–‡ä»¶éƒ½ç”±ä¸€ç³»åˆ—é”®å€¼å¯¹ç»„æˆï¼Œå…¶è¯­æ³•å¦‚ä¸‹:

```
<#BUILD_SETTING_NAME#> = <#value#>
```

For example,
to specify the Swift language version for a project,
you'd specify the `SWIFT_VERSION` build setting like so:

ä¾‹å¦‚ï¼Œä½ å¯ä»¥é€šè¿‡ä¸‹é¢è¿™æ ·çš„ `SWIFT_VERSION` Build Settingï¼ŒæŒ‡å®šé¡¹ç›®çš„ Swift è¯­è¨€ç‰ˆæœ¬ï¼š

```
SWIFT_VERSION = 5.0
```

{% info %}

According to the [<abbr title="Portable Operating System Interface">POSIX</abbr> standard](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08)
environment variables have names consisting solely of
uppercase letters, digits, and underscore (`_`) ---
a convention I like to call `SCREAMING_SNAKE_CASE` ğŸğŸ—¯.

> æ ¹æ® [<abbr title="Portable Operating System Interface">POSIX</abbr> æ ‡å‡†](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08)ï¼Œç¯å¢ƒå˜é‡çš„åå­—ç”±å…¨å¤§å†™å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ï¼ˆ`_`ï¼‰ç»„æˆ â€”â€” ç»å…¸ä¾‹å­å°±æ˜¯ `SCREAMING_SNAKE_CASE` ğŸğŸ—¯ã€‚

{% endinfo %}

---

At first glance,
`xcconfig` files bear a striking resemblance to `.env` files,
with their simple, newline-delimited syntax.
But there's more to Xcode build configuration files than meets the eye.
_Behold!_

ä¹ä¸€çœ‹ï¼Œ`xcconfig` æ–‡ä»¶ä¸ `.env` æ–‡ä»¶æœ‰æƒŠäººçš„ç›¸ä¼¼ä¹‹å¤„ï¼Œå®ƒä»¬çš„è¯­æ³•éƒ½å¾ˆç®€å•ï¼Œéƒ½ä»¥æ¢è¡Œåˆ†éš”ã€‚ä½†æ˜¯ï¼ŒXcode Build é…ç½®æ–‡ä»¶çš„å†…å®¹æ¯”è¡¨é¢ä¸Šçœ‹åˆ°çš„è¦å¤šã€‚_çœ‹å“ª!_

### Retaining Existing Values

### ä¿ç•™ç°æœ‰å€¼

To append rather than replace existing definitions,
use the `$(inherited)` variable like so:

è¦è¿½åŠ æ–°å†…å®¹ï¼Œè€Œä¸æ˜¯æ›¿æ¢ç°æœ‰å®šä¹‰æ—¶ï¼Œå¯ä»¥åƒè¿™æ ·ä½¿ç”¨ `$(inherited)` å˜é‡:

```
<#BUILD_SETTING_NAME#> = $(inherited)<#additional value#>
```

You typically do this to build up lists of values,
such as the paths in which
the compiler searches for frameworks
to find included header files
(`FRAMEWORK_SEARCH_PATHS`):

è¿™ä¹ˆåšé€šå¸¸æ˜¯ä¸ºäº†æ­å»ºä¸€äº›å€¼çš„åˆ—è¡¨ï¼Œæ¯”å¦‚ç¼–è¯‘å™¨çš„ framework å¤´æ–‡ä»¶çš„æœç´¢è·¯å¾„(`FRAMEWORK_SEARCH_PATHS`):

```
FRAMEWORK_SEARCH_PATHS = $(inherited) $(PROJECT_DIR)
```

Xcode assigns inherited values in the following order
(from lowest to highest precedence):

Xcode æŒ‰ä¸‹é¢çš„é¡ºåºå¯¹ `inherited` è¿›è¡Œèµ‹å€¼ï¼ˆä¼˜å…ˆçº§ä»ä½åˆ°é«˜ï¼‰ï¼š

- Platform Defaults
- Xcode Project File Build Settings
- xcconfig File for the Xcode Project
- Active Target Build Settings
- xcconfig File for the Active Target

- å¹³å°é»˜è®¤å€¼ï¼ˆPlatform Defaultsï¼‰
- Xcode é¡¹ç›®æ–‡ä»¶çš„ Build Settingï¼ˆXcode Project File Build Settingsï¼‰
- Xcode é¡¹ç›®çš„ xcconfig æ–‡ä»¶ï¼ˆxcconfig File for the Xcode Projectï¼‰
- Active Target çš„ Build Settingï¼ˆActive Target Build Settingsï¼‰
- Active Target çš„ xcconfig æ–‡ä»¶ï¼ˆxcconfig File for the Active Targetï¼‰

{% info %}
Spaces are used to delimit items in string and path lists.
To specify an item containing whitespace,
you must enclose it with quotation marks (`"`).

> ç©ºæ ¼ç”¨äºåˆ†éš”å­—ç¬¦ä¸²å’Œè·¯å¾„åˆ—è¡¨ä¸­çš„é¡¹ã€‚æŒ‡å®šåŒ…å«ç©ºæ ¼çš„é¡¹æ—¶ï¼Œå¿…é¡»ç”¨å¼•å·(`"`)æ‹¬èµ·æ¥ã€‚

{% endinfo %}

### Referencing Values

### å¼•ç”¨å…¶ä»–å€¼

You can substitute values from other settings
by their declaration name
with the following syntax:

ä½ å¯ä»¥æŒ‰ç…§ä¸‹é¢çš„è¯­æ³•ï¼Œé€šè¿‡å…¶ä»–è®¾ç½®çš„åå­—å¼•ç”¨å®ƒä»¬çš„å€¼ï¼š

```
<#BUILD_SETTING_NAME#> = $(<#ANOTHER_BUILD_SETTING_NAME#>)
```

Substitutions can be used to
define new variables according to existing values,
or inline to build up new values dynamically.

è¿™ç§å¼•ç”¨å¯ä»¥ç”¨äºæ ¹æ®ç°æœ‰å€¼å®šä¹‰æ–°å˜é‡ï¼Œä¹Ÿå¯ä»¥ç”¨äºä»¥å†…è”æ–¹å¼åŠ¨æ€æ„å»ºæ–°å€¼ã€‚

```
OBJROOT = $(SYMROOT)
CONFIGURATION_BUILD_DIR = $(BUILD_DIR)/$(CONFIGURATION)-$(PLATFORM_NAME)
```

### Conditionalizing

### æ¡ä»¶çº¦æŸ

You can conditionalize build settings according to their
SDK (`sdk`), architecture (`arch`), and / or configuration (`config`)
according to the following syntax:

ä½¿ç”¨ä»¥ä¸‹è¯­æ³•ï¼Œä½ å¯ä»¥æŒ‰ SDK (`sdk`)ã€æ¶æ„ (`arch`)å’Œ / æˆ–é…ç½®(`config`)å¯¹ Build Setting è¿›è¡Œæ¡ä»¶çº¦æŸï¼š

```
<#BUILD_SETTING_NAME#>[sdk=<#sdk#>] = <#value for specified sdk#>
<#BUILD_SETTING_NAME#>[arch=<#architecture#>] = <#value for specified architecture#>
<#BUILD_SETTING_NAME#>[config=<#configuration#>] = <#value for specified configuration#>
```

Given a choice between multiple definitions of the same build setting,
the compiler resolves according to specificity.

å¦‚æœéœ€è¦åœ¨åŒä¸€ Build Setting çš„å¤šä¸ªå®šä¹‰ä¹‹é—´è¿›è¡Œé€‰æ‹©ï¼Œç¼–è¯‘å™¨å°†æ ¹æ®æ¡ä»¶çº¦æŸè¿›è¡Œè§£æã€‚

```
<#BUILD_SETTING_NAME#>[sdk=<#sdk#>][arch=<#architecture#>] = <#value for specified sdk and architectures#>
<#BUILD_SETTING_NAME#>[sdk=*][arch=<#architecture#>] = <#value for all other sdks with specified architecture#>
```

For example,
you might specify the following build setting
to speed up local builds by only compiling for the active architecture:

ä¾‹å¦‚ï¼Œä½ å¯ä»¥ä½¿ç”¨ä¸‹é¢è¿™æ¡ Build Setting æŒ‡å®šä»…ç¼–è¯‘ active architectureï¼Œä»è€Œæå‡æœ¬åœ° Build çš„é€Ÿåº¦ã€‚

```
ONLY_ACTIVE_ARCH[config=Debug][sdk=*][arch=*] = YES
```

### Including Settings from Other Configuration Files

### å¼•ç”¨å…¶ä»–é…ç½®æ–‡ä»¶ä¸­çš„è®¾ç½®

A build configuration file can include settings from other configuration files
using the same `#include` syntax
as the equivalent `C` directive
on which this functionality is based:

è·Ÿ `C` è¯­è¨€çš„ `#include` æŒ‡ä»¤ä¸€æ ·ï¼ŒBuild é…ç½®æ–‡ä»¶ä¹Ÿå¯ä»¥ä½¿ç”¨è¿™ç§è¯­æ³•æ¥å¼•ç”¨å…¶ä»–é…ç½®æ–‡ä»¶ä¸­çš„è®¾ç½®ã€‚

```
#include "<#path/to/File.xcconfig#>"
```

As we'll see later on in the article,
you can take advantage of this to build up cascading lists of build settings
in really powerful ways.

æ­£å¦‚æˆ‘ä»¬å°†åœ¨æœ¬æ–‡åé¢çœ‹åˆ°çš„ï¼Œä½ å¯ä»¥åˆ©ç”¨è¿™ä¸€ç‚¹ï¼Œä»¥éå¸¸å¼ºå¤§çš„æ–¹å¼æ­å»ºèµ· Build Setting çš„çº§è”åˆ—è¡¨ã€‚

{% info %}
Normally when the compiler encounters an `#include` directive
that can't be resolved,
it raises an error.
But `xcconfig` files also support an `#include?` directive,
that doesn't complain if the file can't be found.

> æ­£å¸¸æ¥è¯´ï¼Œå½“é‡åˆ°ä¸€ä¸ªæ— æ³•è§£æçš„ `#include` æŒ‡ä»¤æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚ä½†æ˜¯ `xcconfig` æ–‡ä»¶åŒæ—¶ä¹Ÿæ”¯æŒ `#include?` æŒ‡ä»¤ï¼Œåœ¨è¯¥æŒ‡ä»¤ä¸‹ï¼Œè‹¥æ–‡ä»¶æ— æ³•æ‰¾åˆ°ï¼Œç¼–è¯‘å™¨ä¸ä¼šæŠ¥é”™ã€‚

There aren't many cases in which you'd want
the existence or nonexistence of a file
to change compile-time behavior;
after all, builds are best when they're predictable.
But you might use this
as a hook for optional development tools like [Reveal](https://revealapp.com/),
which requires the following configuration:

> æ ¹æ®æ–‡ä»¶æ˜¯å¦å­˜åœ¨è€Œæ”¹å˜ç¼–è¯‘æ—¶è¡Œä¸ºçš„æƒ…å†µå¹¶ä¸å¤šï¼›æ¯•ç«Ÿï¼ŒBuild æœ€å¥½æ˜¯å¯é¢„è§çš„ã€‚ä½†æ˜¯ä½ å¯ä»¥æŠŠå®ƒç”¨åœ¨å¯é€‰çš„å¼€å‘å·¥å…·ä¸Šï¼Œæ¯”å¦‚ [Reveal](https://revealapp.com/) éœ€è¦ä»¥ä¸‹çš„é…ç½®ï¼š

> ```
> # Reveal.xcconfig
> OTHER_LDFLAGS = $(inherited) -weak_framework RevealServer
> FRAMEWORK_SEARCH_PATHS = $(inherited) /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries
> ```

{% endinfo %}

## Creating Build Configuration Files

## åˆ›å»º Build é…ç½®æ–‡ä»¶

To create a build configuration file,
select the "File > New File..." menu item (<kbd>âŒ˜</kbd><kbd>N</kbd>),
scroll down to the section labeled "Other",
and select the Configuration Settings File template.
Next, save it somewhere in your project directory,
making sure to add it to your desired targets

è¦åˆ›å»º Build é…ç½®æ–‡ä»¶ï¼Œè¯·é€‰æ‹© "File > New File..." èœå•é¡¹ï¼ˆ<kbd>âŒ˜</kbd><kbd>N</kbd>ï¼‰ï¼Œä¸‹æ‹‰åˆ° "Other" éƒ¨åˆ†ï¼Œé€‰ä¸­ Configuration Settings File æ¨¡æ¿ã€‚å°†å®ƒä¿å­˜åˆ°ä½ çš„é¡¹ç›®ç›®å½•ï¼Œå¹¶ç¡®ä¿å®ƒåœ¨ä½ æœŸæœ›çš„ target ä¸Šã€‚

<picture>
    <source srcset="{% asset xcconfig-new-file--dark.png @path %}" media="(prefers-color-scheme: dark)">
    <img src="{% asset xcconfig-new-file--light.png @path %}" alt="Xcode new configuration file">
</picture>

![](https://nshipster.com/assets/xcconfig-new-file--light-1569134f8ecaeaee6640f28e544443da0136ff72b00f9343126147934ac134d4.png)

Once you've created an `xcconfig` file,
you can assign it to one or more build configurations
for its associated targets.

åˆ›å»ºå¥½ `xcconfig` æ–‡ä»¶åï¼Œä½ å°±å¯ä»¥å°†å®ƒåˆ†é…ç»™å¯¹åº” target çš„ä¸€ä¸ªæˆ–å¤šä¸ª Build é…ç½®ã€‚

<picture>
    <source srcset="{% asset xcconfig-project-configurations--dark.png @path %}" media="(prefers-color-scheme: dark)">
    <img src="{% asset xcconfig-project-configurations--light.png @path %}" alt="Xcode project configuration">
</picture>

![](https://nshipster.com/assets/xcconfig-project-configurations--light-a82440e27f27e3b139ab51c7317780c6b4a017dfcc56532972da5d521f1f0988.png)

---

Now that we've covered the basics of using Xcode build configuration files
let's look at a couple of examples of how you can use them
to manage development, stage, and production environments.

ç°åœ¨æˆ‘ä»¬å·²ç»ä»‹ç»äº† Xcode Build é…ç½®æ–‡ä»¶ä½¿ç”¨çš„åŸºç¡€çŸ¥è¯†ï¼Œé‚£ä¹ˆè®©æˆ‘ä»¬æ¥çœ‹å‡ ä¸ªç¤ºä¾‹ï¼Œçœ‹çœ‹å¦‚ä½•ä½¿ç”¨å®ƒä»¬æ¥ç®¡ç† developmentã€stage å’Œ production ç¯å¢ƒã€‚

---

## Customizing App Name and Icon for Internal Builds

## ä¸ºå†…éƒ¨ç‰ˆæœ¬æä¾›è‡ªå®šä¹‰çš„ APP åç§°å’Œå›¾æ ‡

Developing an iOS app usually involves
juggling various internal builds
on your simulators and test devices
(as well as the latest version from the App Store,
to use as a reference).

å¼€å‘ iOS åº”ç”¨ç¨‹åºæ—¶ï¼Œé€šå¸¸éœ€è¦åœ¨æ¨¡æ‹Ÿå™¨å’Œæµ‹è¯•è®¾å¤‡ä¸Šå®‰è£…å„ç§å†…éƒ¨ç‰ˆæœ¬ï¼ˆåŒæ—¶ä¹Ÿä¼šå®‰è£…åº”ç”¨ç¨‹åºå•†åº—çš„æœ€æ–°ç‰ˆæœ¬ï¼Œä»¥ä¾›å‚è€ƒï¼‰ã€‚

You can make things easier on yourself
with `xcconfig` files that assign each configuration
a distinct name and app icon.

ä½¿ç”¨ `xcconfig` æ–‡ä»¶ï¼Œä½ å¯ä»¥è½»æ¾åœ°ä¸ºæ¯ä¸ªé…ç½®åˆ†é…ä¸€ä¸ªä¸åŒçš„åç§°å’Œ APP å›¾æ ‡ã€‚

```
// Development.xcconfig
PRODUCT_NAME = $(inherited) Î±
ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon-Alpha

---

// Staging.xcconfig
PRODUCT_NAME = $(inherited) Î²
ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon-Beta
```

## Managing Constants Across Different Environments

## ç®¡ç†ä¸åŒç¯å¢ƒä¸‹çš„å¸¸é‡

If your backend developers comport themselves according to the aforementioned
[12 Factor App](https://12factor.net/config) philosophy,
then they'll have separate endpoints for
development, stage, and production environments.

å¦‚æœä½ çš„åç«¯å¼€å‘äººå‘˜ä¹Ÿéµå¾ªå‰é¢æåˆ°çš„ [12 Factor App](https://12factor.net/config) ç†è®ºï¼Œé‚£ä¹ˆä»–ä»¬å°†ä¸º developmentã€stage å’Œ production ç¯å¢ƒæä¾›å•ç‹¬çš„æ¥å£ã€‚

On iOS,
perhaps the most common approach to managing these environments
is to use conditional compilation statements
with build settings like `DEBUG`.

iOS ä¸Šæœ€å¸¸è§çš„ç¯å¢ƒç®¡ç†æ–¹å¼å¯èƒ½å°±æ˜¯ä½¿ç”¨æ¡ä»¶ç¼–è¯‘è¯­å¥ + `DEBUG` è¿™æ ·çš„ Build Setting äº†ã€‚

```swift
import Foundation

#if DEBUG
let apiBaseURL = URL(string: "https://api.example.dev")!
let apiKey = "9e053b0285394378cf3259ed86cd7504"
#else
let apiBaseURL = URL(string: "https://api.example.com")!
let apiKey = "4571047960318d233d64028363dfa771"
#endif
```

This gets the job done,
but runs afoul of the canon of code / configuration separation.

è¿™åªæ˜¯å®Œæˆäº†ä»»åŠ¡ï¼Œä½†æ˜¯ä¸ä»£ç  / é…ç½®åˆ†ç¦»çš„æ ‡å‡†ç›¸å†²çªã€‚

An alternative approach takes these environment-specific values
and puts them where they belong ---
into `xcconfig` files.

å¦ä¸€ä¸ªæ–¹æ¡ˆæ˜¯å°†è¿™äº›ä¸ç¯å¢ƒç›¸å…³çš„å€¼æ”¾åˆ°å®ƒä»¬è¯¥å¾…çš„åœ°æ–¹ â€”â€” `xcconfig` æ–‡ä»¶ä¸­ã€‚

```
// Development.xcconfig
API_BASE_URL = api.example.dev
API_KEY = 9e053b0285394378cf3259ed86cd7504

---

// Production.xcconfig
API_BASE_URL = api.example.com
API_KEY = 4571047960318d233d64028363dfa771
```

{% error %}

Unfortunately, `xcconfig` files treat the sequence
`//` as a comment delimiter,
regardless of whether it's enclosed in quotation marks.
If you try to escape with backslashes `\/\/`,
those backslashes show up literally
and must be removed from the resulting value.
This is especially inconvenient when specifying per-environment URL constants.

> ä¸å¹¸çš„æ˜¯ï¼Œ`xcconfig` å°†æ‰€æœ‰ `//` éƒ½å½“æˆæ³¨é‡Šåˆ†éš”ç¬¦ï¼Œä¸ç®¡å®ƒä»¬æ˜¯å¦åŒ…æ‹¬åœ¨å¼•å·ä¸­ã€‚å¦‚æœä½ ç”¨åæ–œçº¿ `\/\/` è¿›è¡Œè½¬ä¹‰ï¼Œé‚£ä¹ˆè¿™äº›åæ–œçº¿ä¹Ÿå°†è¢«ç›´æ¥å±•ç¤ºå‡ºç°ï¼Œä½¿ç”¨æ—¶å¿…é¡»ä»ç»“æœä¸­ç§»é™¤ã€‚åœ¨æŒ‡å®šæ¯ä¸ªç¯å¢ƒçš„ URL å¸¸é‡æ—¶ï¼Œè¿™å°¤å…¶ä¸æ–¹ä¾¿ã€‚

If you'd rather not work around this unfortunate behavior,
you can always omit the scheme and prepend `https://` in code.
_(You are using https... right?)_

> å¦‚æœä¸æƒ³å¤„ç†è¿™ç§éº»çƒ¦çš„äº‹æƒ…ï¼Œä½ å¯ä»¥åœ¨ `xcconfig` ä¸­å¿½ç•¥ schemeï¼Œç„¶ååœ¨ä»£ç ä¸­æ·»åŠ  `https://`ã€‚_ï¼ˆä½ æ˜¯åœ¨ä½¿ç”¨ httpsâ€¦â€¦å¯¹å§ï¼Ÿï¼‰_

{% enderror %}

However,
to pull these values programmatically,
we'll need to take one additional step:

ç„¶è€Œï¼Œè¦ä»¥ç¼–ç¨‹æ–¹å¼è·å–è¿™äº›å€¼ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªé¢å¤–çš„æ­¥éª¤:

### Accessing Build Settings from Swift

### åœ¨ Swift ä¸­è®¿é—® Build Setting

Build settings defined by
the Xcode project file, `xcconfig` files, and environment variables,
are only available at build time.
When you run the compiled app,
none of that surrounding context is available.
_(And thank goodness for that!)_

ç”± Xcode é¡¹ç›®æ–‡ä»¶ã€`xcconfig` æ–‡ä»¶å’Œç¯å¢ƒå˜é‡å®šä¹‰çš„ Build Setting åªåœ¨ Build æ—¶å¯ç”¨ã€‚å½“ä½ è¿è¡Œä¸€ä¸ªå·²ç»ç¼–è¯‘çš„ APP æ—¶ï¼Œæ‰€æœ‰ç›¸å…³çš„ä¸Šä¸‹æ–‡éƒ½æ˜¯ä¸å¯è§çš„ã€‚_ï¼ˆè°¢å¤©è°¢åœ°ï¼ï¼‰_

But wait a sec ---
don't you remember seeing some of those build settings before
in one of those other tabs?
Info, was it?

ä½†æ˜¯ç­‰ä¸€ä¸‹â€”â€”ä½ ä¸è®°å¾—ä¹‹å‰åœ¨å…¶ä»–é€‰é¡¹å¡ä¸­çœ‹åˆ°è¿‡ä¸€äº› Build Setting å—ï¼ŸInfoï¼Œæ˜¯å—ï¼Ÿ

As it so happens,
that info tab is actually just a fancy presentation of
the target's `Info.plist` file.
At build time,
that `Info.plist` file is compiled
according to the build settings provided
and copied into the resulting app [bundle](/bundles-and-packages/).
Therefore,
by adding references to `$(API_BASE_URL)` and `$(API_KEY)`,
you can access the values for those settings
through the `infoDictionary` property of Foundation's `Bundle` API.
_Neat!_

å®é™…ä¸Šï¼ŒInfo tab åªæ˜¯ target çš„ `Info.plist` æ–‡ä»¶çš„ä¸€ä¸ªé©¬ç”²ã€‚Build æ—¶ï¼Œè¿™ä¸ª `Info.plist` æ–‡ä»¶ä¼šæ ¹æ® Build Setting çš„é…ç½®è¿›è¡Œç¼–è¯‘ï¼Œç„¶åå¤åˆ¶åˆ°æœ€ç»ˆ APP çš„ [bundle](https://nshipster.com/bundles-and-packages/) ä¸­ã€‚å› æ­¤ï¼Œæ·»åŠ  `$(API_BASE_URL)` å’Œ `$(API_KEY)` çš„å¼•ç”¨åï¼Œä½ å¯ä»¥é€šè¿‡ Foundation `Bundle` API çš„ `infoDictionary` å±æ€§è®¿é—®è¿™äº›å€¼ã€‚å®Œç¾ï¼

<picture>
    <source srcset="{% asset xcconfig-project-info-plist--dark.png @path %}" media="(prefers-color-scheme: dark)">
    <img src="{% asset xcconfig-project-info-plist--light.png @path %}" alt="Xcode Info.plist">
</picture>

![](https://nshipster.com/assets/xcconfig-project-info-plist--light-5561d8abf4dca9722875ff1f62b5975c3361f5ea3dfd584b655f3da7d3ceb94b.png)

Following this approach,
we might do something like the following:

æŒ‰ç…§è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥åšå¦‚ä¸‹å·¥ä½œï¼š

```swift
import Foundation

enum Configuration {
    static func value<T>(for key: String) -> T {
        guard let value = Bundle.main.infoDictionary?[key] as? T else {
            fatalError("Invalid or missing Info.plist key: \(key)")
        }

        return value
    }
}

enum API {
    static var baseURL: URL {
        return URL(string: "https://" + Configuration.value(for: "API_BASE_URL"))!
    }

    static var key: String {
        return Configuration.value(for: "API_KEY")
    }
}
```

When viewed from the call site,
we find that this approach harmonizes beautifully
with our best practices ---
not a single hard-coded constant in sight!

ä»è°ƒç”¨çš„è§’åº¦è€ƒè™‘ï¼Œæˆ‘ä»¬å‘ç°è¿™ç§æ–¹æ³•ä¸æˆ‘ä»¬çš„æœ€ä½³å®è·µå®Œç¾åœ°åœ¨ç»“åˆä¸€èµ· â€”â€” æ²¡æœ‰å‡ºç°ä¸€ä¸ªç¡¬ç¼–ç çš„å¸¸é‡!

```swift
let url = URL(string: path, relativeTo: API.baseURL)!
var request = URLRequest(url: url)
request.httpMethod = method
request.addValue(API.key, forHTTPHeaderField: "X-API-KEY")
```

{% warning %}

Don't commit secrets to source code.
Instead,
store them securely in a password manager or the like.

> ä¸è¦æŠŠç§å¯†çš„ä¸œè¥¿å†™åœ¨ä»£ç ä¸­ã€‚ç›¸åï¼Œåº”è¯¥å°†å®ƒä»¬å®‰å…¨åœ°å­˜å‚¨åœ¨å¯†ç ç®¡ç†å™¨æˆ–ç±»ä¼¼çš„ä¸œè¥¿ä¸­ã€‚

To prevent secrets from leaking onto GitHub,
add the following to your `.gitignore` file
(as appropriate):

> ä¸ºäº†é˜²æ­¢ä½ çš„ç§å¯†è¢«æ³„æ¼åˆ° GitHub ä¸Šï¼Œè¯·å°†ä¸‹åˆ—é…ç½®æ·»åŠ åˆ°ä½ çš„ `.gitignore` æ–‡ä»¶ä¸­ï¼ˆæ ¹æ®éœ€è¦ï¼‰ï¼š

> ```
> # .gitignore
> Development.xcconfig
> Staging.xcconfig
> Production.xcconfig
> ```

In place of those files,
some developers like to have placeholder files
(e.g. `Development.sample.xcconfig`)
with all of the expected keys.
When checking out the repository,
the developer copies this file to the non-placeholder location
and fills it out accordingly.


> ä¸€äº›å¼€å‘äººå‘˜å–œæ¬¢ä½¿ç”¨åŒ…å«äº†æ‰€éœ€ key çš„å ä½ç¬¦æ–‡ä»¶ï¼ˆä¾‹å¦‚ Development.sample.xcconfigï¼‰ä»£æ›¿è¿™äº›æ–‡ä»¶ã€‚æ‹‰å–ä»£ç æ—¶ï¼Œå¼€å‘äººå‘˜å†å°†è¯¥æ–‡ä»¶å¤åˆ¶åˆ°éå ä½ç¬¦ä½ç½®ï¼Œå¹¶ç›¸åº”åœ°å¡«å……å®ƒã€‚

{% endwarning %}

---

---

Xcode projects are monolithic, fragile, and opaque.
They're a source of friction for collaboration among team members
and generally a drag to work with.

Xcode é¡¹ç›®æ˜¯å•ä¸€çš„ã€è„†å¼±çš„å’Œä¸é€æ˜çš„ã€‚å®ƒä»¬æ˜¯å›¢é˜Ÿæˆå‘˜åˆä½œæ—¶æ‘©æ“¦çš„æ¥æºï¼Œä¹Ÿå¸¸å¸¸æ˜¯å·¥ä½œçš„ç´¯èµ˜ã€‚

Fortunately,
`xcconfig` files go a long way to address these pain points.
Moving configuration out of Xcode and into `xcconfig` files
confers a multitude of benefits
and offers a way to distance your project from the particulars of Xcode
without leaving the Cupertino-approved "happy path".

å¹¸è¿çš„æ˜¯ï¼Œ`xcconfig` æ–‡ä»¶å¾ˆå¥½åœ°è§£å†³äº†è¿™äº›ç—›ç‚¹ã€‚å°†é…ç½®ä» Xcode ç§»åˆ° `xcconfig` æ–‡ä»¶å¸¦æ¥äº†å¾ˆå¤šå¥½å¤„ï¼Œå¯ä»¥è®©ä½ çš„é¡¹ç›®ä¸ Xcode çš„ç»†èŠ‚ä¿æŒä¸€å®šè·ç¦»ï¼Œä¸å—è‹¹æœå…¬å¸çš„æ£è‚˜ã€‚
